/* This abstract type is used to represent a disjoint union
 * using tuples, for example
 * sum((string, int));  // a disjoint union of `string` or `int`
 * sum((bool, string, array(int)));
 */
type sum<'a>

type arbitrary<'a>

@ocaml.doc(
  "see https://github.com/dubzzz/fast-check/blob/main/documentation/Arbitraries.md#size-explained"
)
type arbitrarySize = [
  | #"-4"
  | #"-3"
  | #"-2"
  | #"-1"
  | #"="
  | #"+1"
  | #"+2"
  | #"+3"
  | #"+4"
  | #xsmall
  | #small
  | #medium
  | #large
  | #xlarge
  | #max
]

// Advanced arbitraries, methods on the arbitrary instances to derive new arbitraries
module Derive = {
  @send external chain: (arbitrary<'a>, 'a => arbitrary<'b>) => arbitrary<'b> = "chain"
  @send external map: (arbitrary<'a>, 'a => 'b) => arbitrary<'b> = "map"
  @send external filter: (arbitrary<'a>, 'a => bool) => arbitrary<'a> = "filter"
  @send external noShrink: arbitrary<'a> => arbitrary<'a> = "noShrink"
  @send external noBias: arbitrary<'a> => arbitrary<'a> = "noBias"
}

module Combinators = {
  // methods on fast-check itself
  @module("fast-check") external constant: 'a => arbitrary<'a> = "constant"
  @module("fast-check") @variadic
  external constantFrom: array<'a> => arbitrary<'a> = "constantFrom"

  // NOT MAPPED fc.clonedConstant - unsure about this - what's fc.cloneMethod?

  @module("fast-check") @variadic
  external mapToConstant: array<{.."num": int, "build": int => 'a}> => arbitrary<'a> =
    "mapToConstant"
  @module("fast-check") @variadic
  external oneOf: array<arbitrary<'a>> => arbitrary<'a> = "oneof"

  // NOT MAPPED fc.frequency - how do we distinguish WeightedArbitrary in the type system?
  // fc.option - renamed, see below

  @module("fast-check") external subArray: array<'a> => arbitrary<array<'a>> = "subarray"
  @module("fast-check")
  external subArrayWithLength: (array<'a>, int, int) => arbitrary<array<'a>> = "subarray"
  @module("fast-check")
  external shuffledSubArray: array<'a> => arbitrary<array<'a>> = "shuffledSubarray"
  @module("fast-check")
  external shuffledSubArrayWithLength: (array<'a>, int, int) => arbitrary<array<'a>> =
    "shuffledSubarray"
  @module("fast-check") external array: arbitrary<'a> => arbitrary<array<'a>> = "array"
  @module("fast-check")
  external arrayWithLength: (arbitrary<'a>, int, int) => arbitrary<array<'a>> = "array"

  @deprecated("use uniqueArray instead") @module("fast-check")
  external set: arbitrary<'a> => arbitrary<array<'a>> = "set"
  @deprecated("use uniqueArrayWithOptions instead") @module("fast-check")
  external setWithLength: (
    arbitrary<'a>,
    int,
    int,
    ~comparator: ('a, 'a) => bool,
  ) => arbitrary<array<'a>> = "set"

  type uniqueArrayOptions
  @obj
  external uniqueArrayOptions: (
    ~minLength: float=?,
    ~maxLength: float=?,
    ~selector: 'a => 'a=?,
    ~comparator: [#SameValue | #SameValueZero | #IsStrictlyEqual]=?,
    ~size: arbitrarySize=?,
    unit,
  ) => uniqueArrayOptions = ""
  @obj
  external uniqueArrayOptionsWithMethodComparator: (
    ~minLength: float=?,
    ~maxLength: float=?,
    ~selector: 'a => 'a=?,
    ~comparator: ('a, 'a) => bool=?,
    ~size: arbitrarySize=?,
    unit,
  ) => uniqueArrayOptions = ""
  @module("fast-check")
  external uniqueArray: arbitrary<'a> => arbitrary<array<'a>> = "uniqueArray"
  @module("fast-check")
  external uniqueArrayWithOptions: (arbitrary<'a>, uniqueArrayOptions) => arbitrary<array<'a>> =
    "uniqueArray"

  // slightly tweaked because tuples are arrays in ReasonML
  // fast-check is not limited to 5,
  @module("fast-check")
  external tuple2: (arbitrary<'a>, arbitrary<'b>) => arbitrary<('a, 'b)> = "tuple"
  @module("fast-check")
  external tuple3: (arbitrary<'a>, arbitrary<'b>, arbitrary<'c>) => arbitrary<('a, 'b, 'c)> =
    "tuple"
  @module("fast-check")
  external tuple4: (
    arbitrary<'a>,
    arbitrary<'b>,
    arbitrary<'c>,
    arbitrary<'d>,
  ) => arbitrary<('a, 'b, 'c, 'd)> = "tuple"
  @module("fast-check")
  external tuple5: (
    arbitrary<'a>,
    arbitrary<'b>,
    arbitrary<'c>,
    arbitrary<'d>,
    arbitrary<'e>,
  ) => arbitrary<('a, 'b, 'c, 'd, 'e)> = "tuple"

  @ocaml.doc("
   * `fc.dictionary<T>(keyArb: Arbitrary<string>, valueArb: Arbitrary<T>): Arbitrary<{[Key:string]:T}>`
   *
   * dictionary containing keys generated using `keyArb` and values generated by `valueArb`
   ")
  @module("fast-check")
  external dictionary: (arbitrary<string>, arbitrary<'a>) => arbitrary<Js.Dict.t<'a>> = "dictionary"

  @ocaml.doc("
   * `fc.record<T>(recordModel: {[Key:string]: Arbitrary<T>}): Arbitrary<{[Key:string]: T}>`
   *
   * record using the incoming arbitraries to generate its values.
   * It comes very useful when dealing with settings.
   * The setting `withDeletedKeys=true` instructs the record generator that it can omit some keys.
   ")
  @module("fast-check")
  external record: Js.Dict.t<arbitrary<'a>> => arbitrary<Js.Dict.t<'a>> = "record"
  @module("fast-check")
  external recordWithDeletedKeys: (
    Js.Dict.t<arbitrary<'a>>,
    {"withDeletedKeys": bool},
  ) => arbitrary<Js.Dict.t<'a>> = "record"
  // shadow for ease of use
  let recordWithDeletedKeys = arb => recordWithDeletedKeys(arb, {"withDeletedKeys": true})
  @ocaml.doc(" generates \"tuples\" but we can't really express that in the type system ")
  @module("fast-check")
  external dedup: (arbitrary<'a>, int) => arbitrary<array<'a>> = "dedup"

  // custom and renamed combinators
  @module("fast-check") external null: arbitrary<'a> => arbitrary<Js.null<'a>> = "option"
  @ocaml.doc("
   * In fast-check `option` uses null. In these bindings, that has been renamed to `null`
   * and this function maps it to the option type.
   ")
  let option: arbitrary<'a> => arbitrary<option<'a>> = arb =>
    Derive.map(null(arb), Js.Null.toOption)

  let list: arbitrary<'a> => arbitrary<list<'a>> = a => Derive.map(array(a), Array.to_list)
}

@module("fast-check") external boolean: unit => arbitrary<bool> = "boolean"

@module("fast-check") external integer: unit => arbitrary<int> = "integer"
@module("fast-check") external integerRange: (int, int) => arbitrary<int> = "integer"
@module("fast-check") external nat: (~max: int=?, unit) => arbitrary<int> = "nat"
@module("fast-check") external maxSafeInteger: unit => arbitrary<int> = "maxSafeInteger"
@module("fast-check") external maxSafeNat: unit => arbitrary<int> = "maxSafeNat"

@module("fast-check") external float_: unit => arbitrary<float> = "float"
@module("fast-check") external floatRange: (float, float) => arbitrary<float> = "float"

@module("fast-check") external double: unit => arbitrary<float> = "double"
@module("fast-check") external doubleRange: (float, float) => arbitrary<float> = "double"

@module("fast-check") external char: unit => arbitrary<string> = "char"
@module("fast-check") external char16bits: unit => arbitrary<string> = "char16bits"
@module("fast-check") external hexa: unit => arbitrary<string> = "hexa"
@module("fast-check") external base64: unit => arbitrary<string> = "base64"
@module("fast-check") external ascii: unit => arbitrary<string> = "ascii"
@module("fast-check") external fullUnicode: unit => arbitrary<string> = "fullUnicode"
@module("fast-check") external unicode: unit => arbitrary<string> = "unicode"

@module("fast-check") external hexaString: unit => arbitrary<string> = "hexaString"
@module("fast-check")
external hexaStringWithLength: (int, int) => arbitrary<string> = "hexaString"
@module("fast-check") external base64String: unit => arbitrary<string> = "base64String"
@module("fast-check")
external base64StringWithLength: (int, int) => arbitrary<string> = "base64String"
@module("fast-check") external string: unit => arbitrary<string> = "string"
@module("fast-check") external stringWithLength: (int, int) => arbitrary<string> = "string"
@module("fast-check") external asciiString: unit => arbitrary<string> = "asciiString"
@module("fast-check")
external asciiStringWithLength: (int, int) => arbitrary<string> = "asciiString"
@module("fast-check") external string16Bits: unit => arbitrary<string> = "string16bits"
@module("fast-check")
external string16BitsWithLength: (int, int) => arbitrary<string> = "string16bits"
@module("fast-check")
external fullUnicodeString: unit => arbitrary<string> = "fullUnicodeString"
@module("fast-check")
external fullUnicodeStringWithLength: (int, int) => arbitrary<string> = "fullUnicodeString"
@module("fast-check") external unicodeString: unit => arbitrary<string> = "unicodeString"
@module("fast-check")
external unicodeStringWithLength: (int, int) => arbitrary<string> = "unicodeString"
@module("fast-check") external stringOf: arbitrary<string> => arbitrary<string> = "stringOf"
@module("fast-check")
external stringOfWithLength: (arbitrary<string>, int, int) => arbitrary<string> = "stringOf"

// TODO More specific strings: json, lorem, etc etc

@module("fast-check") external date: unit => arbitrary<Js.Date.t> = "date"
type dateRange = {
  @as("min")
  dateMin: Js.Date.t,
  @as("max")
  dateMax: Js.Date.t,
}
@module("fast-check") external dateRange: dateRange => arbitrary<Js.Date.t> = "date"

module Objects = {
  // There's no way to express this, so we cheat
  type any
  @ocaml.doc(
    " This is totally unsafe, but objects are the one point where fast-check generates hetrogeneous types "
  )
  external anyArb: arbitrary<'a> => arbitrary<any> = "%identity"

  @deriving({abstract: light})
  type settings = {
    @optional
    maxDepth: int,
    @optional
    maxKeys: int,
    @optional
    key: arbitrary<string>,
    @optional
    values: array<arbitrary<any>>,
    @optional
    withBoxedValues: bool,
    @optional
    withMap: bool,
    @optional
    withSet: bool,
    @optional
    withObjectString: bool,
  }
  @module("fast-check")
  external anything: (~settings: settings=?, unit) => arbitrary<any> = "anything"
  @module("fast-check")
  external object_: (~settings: settings=?, unit) => arbitrary<Js.Dict.t<any>> = "object"
  @module("fast-check") external jsonObject: int => arbitrary<Js.Json.t> = "jsonObject"
  @module("fast-check")
  external unicodeJsonObject: int => arbitrary<Js.Json.t> = "unicodeJsonObject"

  @module("fast-check")
  external letrec: (((. Js.Dict.key) => arbitrary<any>) => Js.Dict.t<arbitrary<any>>) => Js.Dict.t<
    arbitrary<any>,
  > = "letrec"
}

module Context = {
  type t

  @module("fast-check") external context: unit => arbitrary<t> = "context"
  @send external contextLog: (t, string) => unit = "log"
  @send external contextSize: t => int = "size"
}

module Scheduler = {
  type schedulerSequenceItem<'a> = {
    builder: unit => Js.Promise.t<'a>,
    label: string,
  }

  type schedulerInstance

  @send
  external schedule: (schedulerInstance, Js.Promise.t<'a>) => Js.Promise.t<'a> = "schedule"
  @ocaml.doc(
    " Unfortunately returning a function is just currying, so we have to use the uncurried form here "
  )
  @send
  external scheduleFunction: (schedulerInstance, 'a => Js.Promise.t<'t>, . 'a) => Js.Promise.t<'t> =
    "scheduleFunction"
  @send
  external scheduleFunction2: (
    schedulerInstance,
    (. 'a, 'b) => Js.Promise.t<'t>,
    . 'a,
    'b,
  ) => Js.Promise.t<'t> = "scheduleFunction"
  @send
  external scheduleFunction3: (
    schedulerInstance,
    (. 'a, 'b, 'c) => Js.Promise.t<'t>,
    . 'a,
    'b,
    'c,
  ) => Js.Promise.t<'t> = "scheduleFunction"
  @send
  external scheduleFunction4: (
    schedulerInstance,
    (. 'a, 'b, 'c, 'd) => Js.Promise.t<'t>,
    . 'a,
    'b,
    'c,
    'd,
  ) => Js.Promise.t<'t> = "scheduleFunction"
  @send
  external scheduleFunction5: (
    schedulerInstance,
    (. 'a, 'b, 'c, 'd, 'e) => Js.Promise.t<'t>,
    . 'a,
    'b,
    'c,
    'd,
    'e,
  ) => Js.Promise.t<'t> = "scheduleFunction"
  @send external waitAll: (schedulerInstance, unit) => Js.Promise.t<unit> = "waitAll"
  @send external waitOne: (schedulerInstance, unit) => Js.Promise.t<unit> = "waitOne"

  @send external count: (schedulerInstance, unit) => int = "count"

  type scheduledTaskResult = {
    done_: bool,
    faulty: bool,
  }
  type scheduledSequence = {
    done_: bool,
    faulty: bool,
    task: Js.Promise.t<scheduledTaskResult>,
  }
  @send
  external scheduleSequence: (schedulerInstance, array<schedulerSequenceItem<'a>>) => int =
    "scheduleSequence"

  // generated docs include (~constraints: schedulerConstraints=?) but documentation doesn't
  @module("fast-check") external scheduler: unit => arbitrary<schedulerInstance> = "scheduler"
}
