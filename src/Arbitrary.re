/* This abstract type is used to represent a disjoint union
 * using tuples, for example
 * sum((string, int));  // a disjoint union of `string` or `int`
 * sum((bool, string, array(int)));
 */
type sum('a);

type arbitrary('a);

// Advanced arbitraries, methods on the arbitrary instances to derive new arbitraries
module Derive = {
  [@send] external chain: (arbitrary('a), 'a => arbitrary('b)) => arbitrary('b) = "chain";
  [@send] external map: (arbitrary('a), 'a => 'b) => arbitrary('b) = "map";
  [@send] external filter: (arbitrary('a), 'a => bool) => arbitrary('a) = "filter";
  [@send] external noShrink: arbitrary('a) => arbitrary('a) = "noShrink";
  [@send] external noBias: arbitrary('a) => arbitrary('a) = "noBias";
};

module Combinators = {
  // methods on fast-check itself
  [@module "fast-check"] external constant: 'a => arbitrary('a) = "constant";
  [@module "fast-check"] [@variadic]
  external constantFrom: array('a) => arbitrary('a) = "constantFrom";

  // NOT MAPPED fc.clonedConstant - unsure about this - what's fc.cloneMethod?

  [@module "fast-check"] [@variadic]
  external mapToConstant:
    array({
      ..
      "num": int,
      "build": int => 'a,
    }) =>
    arbitrary('a) =
    "mapToConstant";
  [@module "fast-check"] [@variadic]
  external oneOf: array(arbitrary('a)) => arbitrary('a) = "oneof";

  // NOT MAPPED fc.frequency - how do we distinguish WeightedArbitrary in the type system?
  // fc.option - renamed, see below

  [@module "fast-check"] external subArray: array('a) => arbitrary(array('a)) = "subarray";
  [@module "fast-check"]
  external subArrayWithLength: (array('a), int, int) => arbitrary(array('a)) = "subarray";
  [@module "fast-check"]
  external shuffledSubArray: array('a) => arbitrary(array('a)) = "shuffledSubarray";
  [@module "fast-check"]
  external shuffledSubArrayWithLength: (array('a), int, int) => arbitrary(array('a)) =
    "shuffledSubarray";
  [@module "fast-check"] external array: arbitrary('a) => arbitrary(array('a)) = "array";
  [@module "fast-check"]
  external arrayWithLength: (arbitrary('a), int, int) => arbitrary(array('a)) = "array";
  [@module "fast-check"] external set: arbitrary('a) => arbitrary(array('a)) = "set";
  [@module "fast-check"]
  external setWithLength:
    (arbitrary('a), int, int, ~comparator: ('a, 'a) => bool) => arbitrary(array('a)) =
    "set";

  // slightly tweaked because tuples are arrays in ReasonML
  // fast-check is not limited to 5,
  [@module "fast-check"]
  external tuple2: (arbitrary('a), arbitrary('b)) => arbitrary(('a, 'b)) = "tuple";
  [@module "fast-check"]
  external tuple3: (arbitrary('a), arbitrary('b), arbitrary('c)) => arbitrary(('a, 'b, 'c)) =
    "tuple";
  [@module "fast-check"]
  external tuple4:
    (arbitrary('a), arbitrary('b), arbitrary('c), arbitrary('d)) =>
    arbitrary(('a, 'b, 'c, 'd)) =
    "tuple";
  [@module "fast-check"]
  external tuple5:
    (arbitrary('a), arbitrary('b), arbitrary('c), arbitrary('d), arbitrary('e)) =>
    arbitrary(('a, 'b, 'c, 'd, 'e)) =
    "tuple";

  /**
   * `fc.dictionary<T>(keyArb: Arbitrary<string>, valueArb: Arbitrary<T>): Arbitrary<{[Key:string]:T}>`
   *
   * dictionary containing keys generated using `keyArb` and values generated by `valueArb`
   */
  [@module "fast-check"]
  external dictionary: (arbitrary(string), arbitrary('a)) => arbitrary(Js.Dict.t('a)) =
    "dictionary";

  /**
   * `fc.record<T>(recordModel: {[Key:string]: Arbitrary<T>}): Arbitrary<{[Key:string]: T}>`
   *
   * record using the incoming arbitraries to generate its values.
   * It comes very useful when dealing with settings.
   * The setting `withDeletedKeys=true` instructs the record generator that it can omit some keys.
   */
  [@module "fast-check"]
  external record: Js.Dict.t(arbitrary('a)) => arbitrary(Js.Dict.t('a)) = "record";
  [@module "fast-check"]
  external recordWithDeletedKeys:
    (Js.Dict.t(arbitrary('a)), {. "withDeletedKeys": bool}) => arbitrary(Js.Dict.t('a)) =
    "record";
  // shadow for ease of use
  let recordWithDeletedKeys = arb => recordWithDeletedKeys(arb, {"withDeletedKeys": true});
  /** generates "tuples" but we can't really express that in the type system */
  [@module "fast-check"]
  external dedup: (arbitrary('a), int) => arbitrary(array('a)) = "dedup";

  // custom and renamed combinators
  [@module "fast-check"] external null: arbitrary('a) => arbitrary(Js.null('a)) = "option";
  /**
   * In fast-check `option` uses null. In these bindings, that has been renamed to `null`
   * and this function maps it to the option type.
   */
  let option: arbitrary('a) => arbitrary(option('a)) =
    arb => Derive.map(null(arb), Js.Null.toOption);

  let list: arbitrary('a) => arbitrary(list('a)) = a => Derive.map(array(a), Array.to_list);
};

[@module "fast-check"] external boolean: unit => arbitrary(bool) = "boolean";

[@module "fast-check"] external integer: unit => arbitrary(int) = "integer";
[@module "fast-check"] external integerRange: (int, int) => arbitrary(int) = "integer";
[@module "fast-check"] external nat: (~max: int=?, unit) => arbitrary(int) = "nat";
[@module "fast-check"] external maxSafeInteger: unit => arbitrary(int) = "maxSafeInteger";
[@module "fast-check"] external maxSafeNat: unit => arbitrary(int) = "maxSafeNat";

[@module "fast-check"] external float_: unit => arbitrary(float) = "float";
[@module "fast-check"] external floatRange: (float, float) => arbitrary(float) = "float";

[@module "fast-check"] external double: unit => arbitrary(float) = "double";
[@module "fast-check"] external doubleRange: (float, float) => arbitrary(float) = "double";

[@module "fast-check"] external char: unit => arbitrary(string) = "char";
[@module "fast-check"] external char16bits: unit => arbitrary(string) = "char16bits";
[@module "fast-check"] external hexa: unit => arbitrary(string) = "hexa";
[@module "fast-check"] external base64: unit => arbitrary(string) = "base64";
[@module "fast-check"] external ascii: unit => arbitrary(string) = "ascii";
[@module "fast-check"] external fullUnicode: unit => arbitrary(string) = "fullUnicode";
[@module "fast-check"] external unicode: unit => arbitrary(string) = "unicode";

[@module "fast-check"] external hexaString: unit => arbitrary(string) = "hexaString";
[@module "fast-check"]
external hexaStringWithLength: (int, int) => arbitrary(string) = "hexaString";
[@module "fast-check"] external base64String: unit => arbitrary(string) = "base64String";
[@module "fast-check"]
external base64StringWithLength: (int, int) => arbitrary(string) = "base64String";
[@module "fast-check"] external string: unit => arbitrary(string) = "string";
[@module "fast-check"] external stringWithLength: (int, int) => arbitrary(string) = "string";
[@module "fast-check"] external asciiString: unit => arbitrary(string) = "asciiString";
[@module "fast-check"]
external asciiStringWithLength: (int, int) => arbitrary(string) = "asciiString";
[@module "fast-check"] external string16Bits: unit => arbitrary(string) = "string16bits";
[@module "fast-check"]
external string16BitsWithLength: (int, int) => arbitrary(string) = "string16bits";
[@module "fast-check"]
external fullUnicodeString: unit => arbitrary(string) = "fullUnicodeString";
[@module "fast-check"]
external fullUnicodeStringWithLength: (int, int) => arbitrary(string) = "fullUnicodeString";
[@module "fast-check"] external unicodeString: unit => arbitrary(string) = "unicodeString";
[@module "fast-check"]
external unicodeStringWithLength: (int, int) => arbitrary(string) = "unicodeString";
[@module "fast-check"] external stringOf: arbitrary(string) => arbitrary(string) = "stringOf";
[@module "fast-check"]
external stringOfWithLength: (arbitrary(string), int, int) => arbitrary(string) = "stringOf";

// TODO More specific strings: json, lorem, etc etc

[@module "fast-check"] external date: unit => arbitrary(Js.Date.t) = "date";
type dateRange = {
  [@as "min"]
  dateMin: Js.Date.t,
  [@as "max"]
  dateMax: Js.Date.t,
};
[@module "fast-check"] external dateRange: dateRange => arbitrary(Js.Date.t) = "date";

module Objects = {
  // There's no way to express this, so we cheat
  type any;
  /** This is totally unsafe, but objects are the one point where fast-check generates hetrogeneous types */
  external anyArb: arbitrary('a) => arbitrary(any) = "%identity";

  [@deriving {abstract: light}]
  type settings = {
    [@optional]
    maxDepth: int,
    [@optional]
    maxKeys: int,
    [@optional]
    key: arbitrary(string),
    [@optional]
    values: array(arbitrary(any)),
    [@optional]
    withBoxedValues: bool,
    [@optional]
    withMap: bool,
    [@optional]
    withSet: bool,
    [@optional]
    withObjectString: bool,
  };
  [@module "fast-check"]
  external anything: (~settings: settings=?, unit) => arbitrary(any) = "anything";
  [@module "fast-check"]
  external object_: (~settings: settings=?, unit) => arbitrary(Js.Dict.t(any)) = "object";
  [@module "fast-check"] external jsonObject: int => arbitrary(Js.Json.t) = "jsonObject";
  [@module "fast-check"]
  external unicodeJsonObject: int => arbitrary(Js.Json.t) = "unicodeJsonObject";

  [@module "fast-check"]
  external letrec:
    (((. Js.Dict.key) => arbitrary(any)) => Js.Dict.t(arbitrary(any))) =>
    Js.Dict.t(arbitrary(any)) =
    "letrec";
};

module Context = {
  type t;

  [@module "fast-check"] external context: unit => arbitrary(t) = "context";
  [@send] external contextLog: (t, string) => unit = "log";
  [@send] external contextSize: t => int = "size";
};

module Scheduler = {
  type schedulerSequenceItem('a) = {
    builder: unit => Js.Promise.t('a),
    label: string,
  };

  type schedulerInstance;

  [@send]
  external schedule: (schedulerInstance, Js.Promise.t('a)) => Js.Promise.t('a) = "schedule";
  /** Unfortunately returning a function is just currying, so we have to use the uncurried form here */
  [@send]
  external scheduleFunction:
    (schedulerInstance, 'a => Js.Promise.t('t)) => (. 'a) => Js.Promise.t('t) =
    "scheduleFunction";
  [@send]
  external scheduleFunction2:
    (schedulerInstance, (. 'a, 'b) => Js.Promise.t('t)) => (. 'a, 'b) => Js.Promise.t('t) =
    "scheduleFunction";
  [@send]
  external scheduleFunction3:
    (schedulerInstance, (. 'a, 'b, 'c) => Js.Promise.t('t)) => (. 'a, 'b, 'c) => Js.Promise.t('t) =
    "scheduleFunction";
  [@send]
  external scheduleFunction4:
    (schedulerInstance, (. 'a, 'b, 'c, 'd) => Js.Promise.t('t)) =>
    (. 'a, 'b, 'c, 'd) => Js.Promise.t('t) =
    "scheduleFunction";
  [@send]
  external scheduleFunction5:
    (schedulerInstance, (. 'a, 'b, 'c, 'd, 'e) => Js.Promise.t('t)) =>
    (. 'a, 'b, 'c, 'd, 'e) => Js.Promise.t('t) =
    "scheduleFunction";
  [@send] external waitAll: (schedulerInstance, unit) => Js.Promise.t(unit) = "waitAll";
  [@send] external waitOne: (schedulerInstance, unit) => Js.Promise.t(unit) = "waitOne";

  [@send] external count: (schedulerInstance, unit) => int = "count";

  type scheduledTaskResult = {
    done_: bool,
    faulty: bool,
  };
  type scheduledSequence = {
    done_: bool,
    faulty: bool,
    task: Js.Promise.t(scheduledTaskResult),
  };
  [@send]
  external scheduleSequence: (schedulerInstance, array(schedulerSequenceItem('a))) => int =
    "scheduleSequence";

  // generated docs include (~constraints: schedulerConstraints=?) but documentation doesn't
  [@module "fast-check"] external scheduler: unit => arbitrary(schedulerInstance) = "jsonObject";
};
